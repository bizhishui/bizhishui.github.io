---
title: sed & awk
layout: post
guid: urn:uuid:1f6f3a24-f0a3-4b90-abff-a79d92eca8a8
categories:
  - linux
tags:
  - sed
  - awk
---

> This is a note blog for *sed* and *awk*, adapted from [sed & awk](http://docstore.mik.ua/orelly/unix/sedawk/index.htm).

* TOC
{:toc}

#### Understanding Basic Operations
Sed is stream-oriented, it cannot be used interactively. By default, all of the input to sed passes through and goes to standard output. 
The input file itself is not changed. *Sed applies a command* without an address *to every line in the file* (global-line addressing).  
For example

```
    s/regular/complex/   #subsitute every lines contain regular by complex
```

Awk was developed as a programmable editor that, like sed, is stream-oriented and interprets a script of editing commands. 
Where awk departs from sed is in discarding the line-editor command set. It offers in its place a programming language modeled on the C language. 
The print statement replaces the p command, for example. The concept of addressing is carried over, such that:

```
    /regular/ {print }
```

prints those lines matching "regular". The braces ({}) surround a series of one or many statements that applied to the same address.

One of the most distinctive features of awk is that it parses, or breaks up, each input line and makes individual words available for processing with a script.

#### Command-Line Syntax
{:.no_toc}
Sed and awk are invoked in much the same way with command-line syntax:

```
    command [options] script filename
```

The *script must be surround in single quotes if it contains a space or any characters that may be interpreted by the shell*. One option common
to both sed and awk is the *-f* option that allows your to specify the name of a script file. As a script grows in size, it is convenient to place
it in a file. With scriptfile, each program reads one input line at a time from the input file, makes a copy of the input line, and 
executes the instructions specified in the script on that copy. Thus the command is 

```
    command -f scriptfile filename
```

In sed and awk, each instruction has two parts: a *pattern* and a *procedure*. The pattern is a regular expression delimited with slashed (/).
A procedure specifies one or more actions to be performed.  
As each line of input is read, the program reads the first instruction in the script and checks the pattern against the current line. 
If there is no match, the procedure is ignored and the next instruction is read. If there is a match, then the action or actions specified in the procedure are followed. 
All of the instructions are read, not just the first instruction that matches the input line.  
When all the applicable instructions have been interpreted and applied for a single line, sed outputs the line and repeats the cycle for each input line. 
Awk, on the other hand, does not automatically output the line; the instructions in your script control what is finally done with it.

```
    #command-line options for sed and examples
    -e      Editing instruction follows                 #sed -e 's/ MA/, Massachusetts/' -e 's/ PA/, Pennsylvania/' list.txt
    -f      Filename of script follows                  #sed -f sedscr list.txt
    -n      Suppress automatic output of input lines    # only affected streams are output
    sed 's/ MA/, Massachusetts/; s/ PA/, Pennsylvania/' list.txt   #another way for multiple instructions
    sed -f sedscr list.txt > newlist.txt                #redirect output to file newlist.txt
```

#### Using awk
{:.no_toc}
Awk, in the usual case, interprets each input line as a record and each word on that line, delimited by spaces or tabs, 
as a field. (These defaults can be changed.) One or more consecutive spaces or tabs count as a single delimiter. 
Awk allows you to reference these fields, in either patterns or procedures. *$0* represents the entire input line. *$1, $2, ...* refer 
to the individual fields on the input line. Awk splits the input record before the script is applied.  
In awk, **regular expression need enclose within slashes (//)**

```
    #options and examples
    -f    Filename of script follows
    -F    Change file separator
    -v    var=value follows
    awk '{ print $1 }' list.txt                   #print the first field of each line in the input file
    awk '/MA/ { print $1 }' list.txt              #match lines contain MA (regular expression) and print first field of those lines
    awk -F, '/MA/ { print $1 }' list.txt          #space and tab are default delimiters for awk, -F, set ',' as a delimiter in this case
```

#### Using sed and awk Together
{:.no_toc}
In UNIX, pipes can be used to pass the output from one program as input to the next program. Like below,

```
    #sedScr is a sed script
    sed -f sedScr list.txt | awk -F, '{ print $4 }'        #awk program is processing the output produced by the sed script
    aek -F, '{ print $4 ", " $0 }' $* | sore    #use ',' as separator, awk produces new line with '$4, ' and the original line, the those new lines ($*) are sorted 
```


### Understanding Regular Expression Syntax

```
    #summary of metacharacters
    .       matches any single character except newline
    *       Matches any number (including zero) of the single character (including a character specified by a regular expression) that immediately precedes it.
    ^       First character of regular expression, matches the beginning of the line. Matches the beginning of a string in awk, even if the string contains embedded newlines.
    $       As last character of regular expression, matches the end of the line. Matches the end of a string in awk, even if the string contains embedded newlines.
    [...]   Matches any one of the class of characters enclosed between the brackets. All other metacharacters lose their meaning when specified as members of a class.
            A circumflex (^) as first character inside brackets reverses the match to all characters except newline and those listed in the class. In awk, newline will also match. 
            A hyphen (-) is used to indicate a range of characters.
            The close bracket (]) as the first character in class is a member of the class. 
    \       Escapes the special character that follows.
    +       Matches one or more occurrences of the preceding regular expression.
    ?       Matches zero or one occurrences of the preceding regular expression.
    |       Specifies that either the preceding or following regular expression can be matched (alternation).
```

##### The Ubiquitous Backslash
{:.no_toc}
The backslash (\) metacharacter transforms metacharacters into ordinary characters (and ordinary characters into metacharacters).

##### Writing Regular Expressions
{:.no_toc}
The process of writing a regular expression involves three steps:

1. Knowing what it is you want to match and how it might appear in the text.
2. Writing a pattern to describe what you want to match.
3. Testing the pattern to see what it matches.

##### Character Classes
{:.no_toc}
A character class is a refinement of the wildcard concept. Instead of matching any character at a specific position, we can list the characters to be matched. 
The square bracket metacharacters ([]) enclose the list of characters, any of which can occupy a single position.
For example, `[Ww]hat` will match any string contains *what* or *What*. While `[^0-9]` will match any non-numeric character.

##### Positional Metacharacters
{:.no_toc}
There are two metacharacters that allow you to specify the context in which a string appears, either at the beginning of a line or at the end of a line. 
The circumflex (^) metacharacter is a single-character regular expression indicating the beginning of a line. The dollar sign (`$`) metacharacter 
is a single-character regular expression indicating the end of a line. These are often referred to as "anchors," since they anchor, 
or restrict, the match to a specific position. Thus `^$` will match a blank line.

##### A Span of Characters
{:.no_toc}
`\{ n , m \}` use to match k (``k\in[n,m]``) occurrences of the preceding character, `10\{2,4\}1` can match 1001,10001 or 100001, for example. 


### Writing sed Scripts
Sed applies the entire script to the first input line before reading the second input line and applying the editing script to it. 
Because sed is always working with the latest version of the original line, any edit that is made changes the line for subsequent commands. 
Sed doesn't retain the original. This means that a pattern that might have matched the original input line may no longer match the line after an edit has been made.

#### A Global Perspective on Addressing
{:.no_toc}
Line addresses are used to supply context for, or restrict , an operation. (In short: Nothing gets done in vi unless you tell it which lines to work on, while sed will work on every line unless you tell it not to.)

```
    s/CA/California/g         #vi, subsitute all CA to California on current line
                              #sed, subsitute all CA to California for all input line
    /Sebastopol/s/CA/California/g   #sed, will only subsitute lines contain Sebastopol
```

A sed command can specify zero, one, or two addresses. An address can be a regular expression describing a pattern, a line number, or a line addressing symbol.

- If no address is specified, then the command is applied to each line.
- If there is only one address, the command is applied to any line matching the address.
- If two comma-separated addresses are specified, the command is performed on the first line matching the first address and all succeeding lines up to and including a line matching the second address.
- If an address is followed by an exclamation mark ( ! ), the command is applied to all lines that do not match the address.

For example:

```
    d               #delete all lines
    1d              #delete only the first line
    $d              #delete the last line of input
    /^$/d           #only delete blank line
    50,$d           #delete from line 50 to the end
    1,/^$/d         #delete from the first line up to the first blank line
```

#### Four Types of sed Scripts
{:.no_toc}

##### Multiple Edits to the Same File
{:.no_toc}
