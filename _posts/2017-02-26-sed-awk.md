---
title: Sed & awk
layout: post
guid: urn:uuid:1f6f3a24-f0a3-4b90-abff-a79d92eca8a8
categories:
  - linux
tags:
  - sed
  - awk
---

> This is a note blog for *sed* and *awk*, adapted from [sed & awk](http://docstore.mik.ua/orelly/unix/sedawk/index.htm).

* TOC
{:toc}

#### Understanding Basic Operations
Sed is stream-oriented, it cannot be used interactively. By default, all of the input to sed passes through and goes to standard output. 
The input file itself is not changed. *Sed applies a command* without an address *to every line in the file* (global-line addressing).  
For example

```
    s/regular/complex/   #subsitute every lines contain regular by complex
```

Awk was developed as a programmable editor that, like sed, is stream-oriented and interprets a script of editing commands. 
Where awk departs from sed is in discarding the line-editor command set. It offers in its place a programming language modeled on the C language. 
The print statement replaces the p command, for example. The concept of addressing is carried over, such that:

```
    /regular/ {print }
```

prints those lines matching "regular". The braces ({}) surround a series of one or many statements that applied to the same address.

One of the most distinctive features of awk is that it parses, or breaks up, each input line and makes individual words available for processing with a script.

#### Command-Line Syntax
{:.no_toc}
Sed and awk are invoked in much the same way with command-line syntax:

```
    command [options] script filename
```

The *script must be surround in single quotes if it contains a space or any characters that may be interpreted by the shell*. One option common
to both sed and awk is the *-f* option that allows your to specify the name of a script file. As a script grows in size, it is convenient to place
it in a file. With scriptfile, each program reads one input line at a time from the input file, makes a copy of the input line, and 
executes the instructions specified in the script on that copy. Thus the command is 

```
    command -f scriptfile filename
```

In sed and awk, each instruction has two parts: a *pattern* and a *procedure*. The pattern is a regular expression delimited with slashed (/).
A procedure specifies one or more actions to be performed.  
As each line of input is read, the program reads the first instruction in the script and checks the pattern against the current line. 
If there is no match, the procedure is ignored and the next instruction is read. If there is a match, then the action or actions specified in the procedure are followed. 
All of the instructions are read, not just the first instruction that matches the input line.  
When all the applicable instructions have been interpreted and applied for a single line, sed outputs the line and repeats the cycle for each input line. 
Awk, on the other hand, does not automatically output the line; the instructions in your script control what is finally done with it.

```
    #command-line options for sed and examples
    -e      Editing instruction follows                 #sed -e 's/ MA/, Massachusetts/' -e 's/ PA/, Pennsylvania/' list.txt
    -f      Filename of script follows                  #sed -f sedscr list.txt
    -n      Suppress automatic output of input lines    # only affected streams are output
    sed 's/ MA/, Massachusetts/; s/ PA/, Pennsylvania/' list.txt   #another way for multiple instructions
    sed -f sedscr list.txt > newlist.txt                #redirect output to file newlist.txt
```

#### Using awk
{:.no_toc}
Awk, in the usual case, interprets each input line as a record and each word on that line, delimited by spaces or tabs, 
as a field. (These defaults can be changed.) One or more consecutive spaces or tabs count as a single delimiter. 
Awk allows you to reference these fields, in either patterns or procedures. *$0* represents the entire input line. *$1, $2, ...* refer 
to the individual fields on the input line. Awk splits the input record before the script is applied.  
In awk, **regular expression need enclose within slashes (//)**

```
    #options and examples
    -f    Filename of script follows
    -F    Change file separator
    -v    var=value follows
    awk '{ print $1 }' list.txt                   #print the first field of each line in the input file
    awk '/MA/ { print $1 }' list.txt              #match lines contain MA (regular expression) and print first field of those lines
    awk -F, '/MA/ { print $1 }' list.txt          #space and tab are default delimiters for awk, -F, set ',' as a delimiter in this case
```

#### Using sed and awk Together
{:.no_toc}
In UNIX, pipes can be used to pass the output from one program as input to the next program. Like below,

```
    #sedScr is a sed script
    sed -f sedScr list.txt | awk -F, '{ print $4 }'        #awk program is processing the output produced by the sed script
    aek -F, '{ print $4 ", " $0 }' $* | sore    #use ',' as separator, awk produces new line with '$4, ' and the original line, the those new lines ($*) are sorted 
```


### Understanding Regular Expression Syntax

```
    #summary of metacharacters
    .       matches any single character except newline
    *       Matches any number (including zero) of the single character (including a character specified by a regular expression) that immediately precedes it.
    ^       First character of regular expression, matches the beginning of the line. Matches the beginning of a string in awk, even if the string contains embedded newlines.
    $       As last character of regular expression, matches the end of the line. Matches the end of a string in awk, even if the string contains embedded newlines.
    [...]   Matches any one of the class of characters enclosed between the brackets. All other metacharacters lose their meaning when specified as members of a class.
            A circumflex (^) as first character inside brackets reverses the match to all characters except newline and those listed in the class. In awk, newline will also match. 
            A hyphen (-) is used to indicate a range of characters.
            The close bracket (]) as the first character in class is a member of the class. 
    \       Escapes the special character that follows.
    +       Matches one or more occurrences of the preceding regular expression.
    ?       Matches zero or one occurrences of the preceding regular expression.
    |       Specifies that either the preceding or following regular expression can be matched (alternation).
```
